{"version":3,"file":"static/js/1138.41304eb0.chunk.js","mappings":"2FAgDAA,EAAOC,QA5BS,SAASC,EAAWC,EAAQC,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GAOzD,IAAKP,EAAW,CACd,IAAIQ,EACJ,QAAeC,IAAXR,EACFO,EAAQ,IAAIE,MACV,qIAGG,CACL,IAAIC,EAAO,CAACT,EAAGC,EAAGC,EAAGC,EAAGC,EAAGC,GACvBK,EAAW,GACfJ,EAAQ,IAAIE,MACVT,EAAOY,QAAQ,MAAO,WAAa,OAAOF,EAAKC,IAAa,KAExDE,KAAO,qBACf,CAGA,MADAN,EAAMO,YAAc,EACdP,CACR,CACF,C,0GCnBA,SArByBQ,EAAAA,EAAAA,GAItB,SAACC,G,MACMC,GAAMC,EAAAA,EAAAA,MAAiBD,EAC/B,OACEE,EAAAA,cAACC,EAAAA,QAAW,CACVC,MAAO,CAAEC,aAAc,GACvBC,OAAOC,EAAAA,EAAAA,GAAcR,EAAMS,OAC3BC,cAA6B,QAAdC,EAAAV,EAAED,EAAMY,cAAM,IAAAD,EAAAA,EAAI,GACjCE,SAAU,SAACC,GACTd,EAAMa,UAASE,EAAAA,EAAAA,GAAcD,GAC/B,GAGN,E,mCCtBA,MAAME,EAAc,SACdC,EAAc,KAEpB,SAASC,EAAOC,GACZ,MAAkB,KAAXA,GAAiBH,EAAYI,KAAKD,GAAO,KAAAE,OACrCF,EAAOvB,QAAQqB,EAAa,OAAM,MACvCE,CACV,CAEA,SAASG,EAAaH,EAAQI,GAC1B,MAAMC,EAAUN,EAAOC,GACvB,OAAOK,IAAYL,EAAUI,EAAQ,IAAHF,OAAOF,GAAWA,EAAUK,CAClE,CACA,MAAMC,EAAgB,cAChBC,EAAgB,OAEtB,SAASC,EAASR,GACd,MAAMS,EAAQH,EAAcI,KAAKV,GACjC,OAAOS,EAAQA,EAAM,GAAGhC,QAAQ8B,EAAe,KAAOP,CAC1D,CAWA,MAAMW,EAAY,4EAiFX,MAAMC,EAAWC,OAAOC,OA/E/B,WAAgC,QAAAC,EAAAC,UAAAC,OAAPC,EAAK,IAAAC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAALF,EAAKE,GAAAJ,UAAAI,GAI1B,MAAMC,EAA6B,OAAbH,EAAM,GAEtBxC,EAAO,GAGb,IAAK,IAAI0B,EAAQ,EAAGA,IAAUc,EAAMD,SAAUb,EAAO,CACjD,MAAMkB,EAAOJ,EAAMd,GAEnB,GAAIkB,GAAiB,IAATA,EACR,GAAoB,kBAATA,EAAmB,CAU1B,MAAMb,EAAQE,EAAUD,KAAKY,GAC7B,GAAIb,EAAO,CACP,MAAO,CAAEc,EAAQC,EAAWC,GAAQhB,EAChCc,IAGIA,EAAOG,SAAS,KAChBhD,EAAKiD,QAAQJ,EAAOK,MAAM,MAG1BlD,EAAKiD,KAAKJ,IAGdC,IAKA9C,EAAKiD,KAAKnB,EAASgB,IAEfC,IACAP,EAAMd,KAAWqB,GAG7B,MAKI/C,EAAKiD,KAAKL,EAElB,MACK,GAAIH,MAAMU,QAAQP,IASnB,GAAIA,EAAKL,OAAQ,CACb,MAAMA,EAASa,KAAKC,IAAI3B,EAAQ,EAAGkB,EAAKL,QACxCb,GAASa,EACTC,EAAMc,OAAO5B,EAAQ,EAAGa,KAAWK,EACvC,OAIA5C,EAAKiD,KAAK,GAAKL,EAG3B,CAEA,OAAOD,EAAgB3C,EAAKuD,IAAIlC,GAAUrB,EAAKuD,IAAI9B,GAAc+B,KAAK,GAC1E,EACoD,CAAEnC,SAAQS,Y","sources":["../node_modules/invariant/browser.js","../../../../src/ui/ColorPicker/ColorPickerField.tsx","../node_modules/uniforms/esm/joinName.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n",null,"const escapeMatch = /[.[\\]]/;\nconst escapeRegex = /\"/g;\n/** @internal */\nfunction escape(string) {\n    return string === '' || escapeMatch.test(string)\n        ? `[\"${string.replace(escapeRegex, '\\\\\"')}\"]`\n        : string;\n}\n/** @internal */\nfunction escapeToJoin(string, index) {\n    const escaped = escape(string);\n    return escaped === string ? (index ? `.${string}` : string) : escaped;\n}\nconst unescapeMatch = /^\\[\"(.*)\"]$/;\nconst unescapeRegex = /\\\\\"/g;\n/** @internal */\nfunction unescape(string) {\n    const match = unescapeMatch.exec(string);\n    return match ? match[1].replace(unescapeRegex, '\"') : string;\n}\n// This regular expression splits the string into three parts:\n//   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n//            front (hence prefix). It covers most standard usecases.\n//   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n//               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n//   `rest` is anything following the subscript. The leading dot (`.`)\n//          is stripped (`.a` -> `a`) if there is one. It is empty if\n//          `subscript` is empty.\n//\n// All three parts can be empty!\nconst nameRegex = /^([^.[\\]]*(?:\\.[^.[\\]]+)*)(?:\\.?(\\[\"(?:(?:[^\"]|\\\\\")*?[^\\\\])?\"])\\.?(.*))?$/;\n// eslint-disable-next-line complexity -- The complexity of it _is_ high.\nfunction joinNameImpl(...parts) {\n    // If the first argument is `null`, then we return an escaped array of parts.\n    // Otherwise, an escaped string is returned. As we may modify `parts` later,\n    // this has to be checked now.\n    const returnAsParts = parts[0] === null;\n    // Result parts (not escaped).\n    const name = [];\n    // This cannot be transformed into a `.forEach` loop and the length of it\n    // can not be memoized, as we modify `parts` as we go for performance reasons.\n    for (let index = 0; index !== parts.length; ++index) {\n        const part = parts[index];\n        // All falsy values except `0` are ignored.\n        if (part || part === 0) {\n            if (typeof part === 'string') {\n                // Strings are matched against the regular expression that split it into\n                // three parts (all can be empty):\n                //   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n                //            front (hence prefix). It covers most standard usecases.\n                //   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n                //               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n                //   `rest` is anything following the subscript. The leading dot (`.`)\n                //          is stripped (`.a` -> `a`) if there is one. It is empty if\n                //          `subscript` is empty.\n                const match = nameRegex.exec(part);\n                if (match) {\n                    const [, prefix, subscript, rest] = match;\n                    if (prefix) {\n                        // We could always `.split` the `prefix`, but it results in a severe\n                        // performance hit.\n                        if (prefix.includes('.')) {\n                            name.push(...prefix.split('.'));\n                        }\n                        else {\n                            name.push(prefix);\n                        }\n                    }\n                    if (subscript) {\n                        // We could adjust the `nameRegex` to skip brackets and `unescape`\n                        // to skip this check, but then every other call (e.g., a one in the\n                        // bridge) would have to know that. The performance is not affected\n                        // much by it anyway.\n                        name.push(unescape(subscript));\n                        // The `rest` is inlined in place as it is a single string.\n                        if (rest) {\n                            parts[index--] = rest;\n                        }\n                    }\n                }\n                else {\n                    // If a string is not matching the pattern, we leave it as it is. We\n                    // may want to raise a warning here as it should not happen. Most\n                    // likely it is something that should have been escaped (e.g., `[`).\n                    name.push(part);\n                }\n            }\n            else if (Array.isArray(part)) {\n                // Arrays are flattened in place but only if needed, i.e., they are not\n                // empty. We calculate the length of the overlapping parts to reuse the\n                // `parts` array as much as possible:\n                // [[], ...]              -> [[], ...]       // No change.\n                // [['a'], ...]           -> ['a', ...]      // Inline in place.\n                // [['a', 'b'], ...]      -> ['a', 'b', ...] // Inline with extension.\n                // ['a', ['b'], ...]      -> ['a', 'b', ...] // Inline in place.\n                // ['a', ['b', 'c'], ...] -> ['b', 'c', ...] // Inline with overlap.\n                if (part.length) {\n                    const length = Math.min(index + 1, part.length);\n                    index -= length;\n                    parts.splice(index + 1, length, ...part);\n                }\n            }\n            else {\n                // Other values -- most likely numbers and `true` -- are stringified.\n                name.push('' + part);\n            }\n        }\n    }\n    // We cannot escape the parts earlier as `escapeToJoin` depends on the index.\n    return returnAsParts ? name.map(escape) : name.map(escapeToJoin).join('');\n}\nexport const joinName = Object.assign(joinNameImpl, { escape, unescape });\n"],"names":["module","exports","condition","format","a","b","c","d","e","f","error","undefined","Error","args","argIndex","replace","name","framesToPop","connectField","props","t","useUiTranslator","React","ColorPicker","style","marginBottom","color","stringToColor","value","buttonContent","_a","label","onChange","v","colorToString","escapeMatch","escapeRegex","escape","string","test","concat","escapeToJoin","index","escaped","unescapeMatch","unescapeRegex","unescape","match","exec","nameRegex","joinName","Object","assign","_len","arguments","length","parts","Array","_key","returnAsParts","part","prefix","subscript","rest","includes","push","split","isArray","Math","min","splice","map","join"],"sourceRoot":""}